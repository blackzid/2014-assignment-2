package ps3.graph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
//import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;
import java.io.Serializable;
import java.util.*;

//import javax.swing.text.html.HTMLDocument.Iterator;

public class Graph<N> implements AbstractGraph<N>, Serializable {
	
	// Representation invariant for every graph g:
		// nodeMap != null
		// && for every node n in the key set of the nodeMap: 
		// 		(n != null && children of n != null)
		// 		for every node c in the children set of n:
		// 			c != null && c is in the graph
		// In other words: the nodeMap, each node in the nodeMap, the children set
		// of each node, and the nodes in each children set are not null and are in
		// the graph.
	
	private static final long serialVersionUID = -8247206763670905121L;
	
	/**
	 * A HashMap which has the nodes of the graph as keys and a HashSet
	 * containing its children as values.
	 */
	private HashMap<N, HashSet<N>> nodeMap;
	
	/**
	 * Constructs an empty Graph.
	 * 
	 * @effects creates an empty Graph.
	 */
	public Graph() {
		nodeMap = new HashMap<N, HashSet<N>>();
		checkRep();
	}
	
	// Specified in AbstractGraph interface
	public void addEdge(N edge_parent, N edge_children) {
		N parent = edge_parent;
		N child = edge_children;
		if (parent == null || child == null || !nodeMap.containsKey(parent)
				|| !nodeMap.containsKey(child))
			throw new IllegalArgumentException();
		nodeMap.get(parent).add(child);
		checkRep();
	}

	// Specified in AbstractGraph interface
	public void addNode(N node) {
		if (node == null)
			throw new IllegalArgumentException();
		if (!nodeMap.containsKey(node)) {
			nodeMap.put(node, new HashSet<N>());
			checkRep();
		}
	}

	// Specified in AbstractGraph interface
	public HashSet<N> listChildren(N node) {
		if (!nodeMap.containsKey(node))
			throw new IllegalArgumentException();
		HashSet<N> children_ = new HashSet<N>();
		children_.addAll(nodeMap.get(node));
		return children_;
	}

	// Specified in AbstractGraph interface
	public HashSet<N> listNodes() {
		HashSet<N> nodes_ = new HashSet<N>();
		nodes_.addAll(nodeMap.keySet());
		return nodes_;
	}
	
	/**
	 * Checks that the representation invariant holds.
	 */
	private void checkRep() {
		if (nodeMap == null)
			throw new RuntimeException("The node map is null.");
		Iterator<N> iter = nodeMap.keySet().iterator();
		while (iter.hasNext()) {
			N node = iter.next();
			if (node == null)
				throw new RuntimeException("A node is null.");
			if (nodeMap.get(node) == null)
				throw new RuntimeException("Children set for a node is null.");
			Iterator<N> childIterator = nodeMap.get(node).iterator();
			while (childIterator.hasNext()) {
				N child_ = childIterator.next();
				if (child_ == null)
					throw new RuntimeException("A child of a node is null.");
				if (!nodeMap.containsKey(child_))
					throw new RuntimeException("One child of a node is not a node of the graph.");
			}
		}
	}

	@Override
	public Collection<N> children(N node) throws IllegalArgumentException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Collection<N> nodes() {
		// TODO Auto-generated method stub
		return null;
	}

	
/*	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		String input_string;
		while (cin.hasNext()) {
			input_string=cin.nextLine();
			//System.out.println(input_string);
			String name[] = input_string.split(" ");
			if(input_string.startsWith("CreateNode")){
				//name[1] == Nodename //name[2] == cost
				System.out.println(name[1] + " " + name[2]);
				
				//WeightedNode(name[1],Integer.parseInt(name[2]));
				
			} else if(input_string.startsWith("CreateGraph")){
				//name[1] == Graphname
				System.out.println(name[1]);
			} else if(input_string.startsWith("AddNode")){
				//name[1] == Graphname //name[2] == Nodename
				System.out.println(name[1] + " " + name[2]);
				
			} else if(input_string.startsWith("AddEdge")){
				//name[1] == Graphname //name[1] == Nodename_from //name[1] == Nodename_to
				System.out.println(name[1] + " " + name[2] + " " + name[3]);
			} else if(input_string.startsWith("ListNodes")){
				//name[1] == Graphname
				System.out.println(name[1]);
			} else if(input_string.startsWith("ListChildren")){
				//name[1] == Graphname //name[2] == Nodename
				System.out.println(name[1] + " " + name[2]);
			} else if(input_string.startsWith("FindPath")){
				//name[1] == Graphname //name[2] == Nodename_from //name[4] == Nodename_to
				System.out.println(name[1] + " " + name[2] + " " + name[4]);
			} 
		}
	}
	*/
}
